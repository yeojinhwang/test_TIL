## 테스트 코드 작성 이유

코드를 작성 후 컴파일을 통해 실행해보는 것은 쉽지만 한계가 많다.

- 첫째, 코드가 바뀔 때마다 이전에 추가했던 기능이 제대로 동작하는지 일일이 검사해야 한다.
- 둘째, 모든 예외를 검사하는데 상당한 시ㅏㄴ과 노력이 든다.
- 셋째, 코드 리팩토링(코드의 동작을 바꾸지 않으면서 코드의 구조를 개선하는 것) 과정에서 코드가 망가지지 않았는지 알 수 있는 쉬운 방법이 없다.

위의 한계로 인해 프로덕션 코드를 작성할 때에 테스트 코드를 작성하는 것이 권장된다.

## 테스트 주도 개발(TDD, Test Driven Development)

```javascript
// 에어비앤비 체크인 리마인더 코드의 일부분

const needsCheckInOrOut = (
    period: string,
    now = new Date(Date.now()),
) => {
    // TODO: needs localization
    const periodMatcher = /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{1,2})–(\d{1,2})/;
    const matched = periodMatcher.exec(period);

    if (matched) {
        // map types to number
        let [, month, startDate, endDate] = matched.map((match) =>
            isNaN(Number(match)) ? match : Number(match),
        );

        // month to number
        month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Oct", "Nov", "Dec"].findIndex(m => m === month)

        const thisMonth = now.getMonth();
        const currentDate = now.getDate();

        let messageType = null;

        if (month === thisMonth && startDate === currentDate) {
            messageType = "check-in";
        }

        if (month === thisMonth && endDate === currentDate) {
            messageType = "check-out";
        }

        return {
            required:
                month === thisMonth &&
                (startDate === currentDate || endDate === currentDate),
            type: messageType,
        };
    }
};

export default needsCheckInOrOut;
```

- string 타입의 period를 받아서 만약 period가 체크인 혹은 체크 아웃 하는 날에 해당되면 다음과 같은 객체를 돌려주는 코드이다.

```json
{
    required: boolean,
    type: "check-in" | "check-out"
}
```

- 테스트 코드 작성

```javascript
describe("needsCheckInOrOut", () => {
    const date = new Date("2019 1. 15.");

    test.each([
        ["Jan 13–18, 2019", date, { required: false, type: null }],
        ["Jan 13–15, 2019", date, { required: true, type: "check-out" }],
        ["Jan 15–17, 2019", date, { required: true, type: "check-in" }],
        ["Jan 20–25, 2019", date, { required: false, type: null }],
        ["2019. 01. 02", date, undefined],
        ["2019. 02. 20-25", date, undefined],
    ])("input: %s, %s)", (a, b, expected) => {
        expect(needsCheckInOrOut(a, b)).toEqual(expected);
    });
});
```

#### 1. 의존성(Dependency)을 외부에서 주입할 수 있게 만들어라.

- `needsCheckInOrOut` 함수의 두 번째 인자인 `now`는 `Date` 객체를 받는다.

  ```javascript
  const needsCheckInOrOut = (
  	period: string,
      now = new Date(Date.now()), // now!
  ) => {
  ```

- 체크인/체크아웃 기준 시간은 `now`를 기준으로 판단하기 때문에 인자로 만들어두면 테스트할 때 사용자가 원하는 임의의 값을 전달할 수 있다.

- 이러한 패턴을 [의존성 주입(Dependency Injection)]([https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85](https://ko.wikipedia.org/wiki/의존성_주입)) 이라 한다.
  - 의존성을 가지는 부분을 외부로부터 제공받기 때문에 테스트하기 훨씬 용이한 코드가 된다.

#### 의존성 주입을 할 수 없는 경우에는 Mock을 사용하라.

- Mock은 실제 함수나 객체가 아니지만 그와 유사한 동작을 제공한다.
- 의존성을 아예 외부 인자로 바꿀 수 있다면 가장 좋지만, 그렇지 않은 경우에는 Mock을 사용할 수 있다.

```javascript
beforeEach(async () => {
    MockDate.set(new Date("2019. 02. 18. 18:20:00"));
})

afterEach(async () => {
    MockDate.reset();
})
```

![image-20200201231239118](images\image-20200201231239118.png)

- Mock은 테스트 피라미드의 가장 아래 단계인 유닛 테스트 단계에서 자주 사용된다.

#### 3. test.each를 사용하면 테스트 케이스를 좀 더 보기 좋게 정리할 수 있다.

- 이 방식의 장점은 누구든지 테스트 케이스를 추가할 수 있고, 나중에 함수의 동작을 알고 싶을 때 테스트 케이스만 보면 쉽게 이해할 수 있다.

```javascript
test.each([
        ["Jan 13–18, 2019", date, { required: false, type: null }],
        ["Jan 13–15, 2019", date, { required: true, type: "check-out" }],
        ["Jan 15–17, 2019", date, { required: true, type: "check-in" }],
        ["Jan 20–25, 2019", date, { required: false, type: null }],
        ["2019. 01. 02", date, undefined],
        ["2019. 02. 20-25", date, undefined],
  ...
```

- 위의 코드를 보면 인자에 따라 함수의 리턴 타입이 어떻게 되는지, 함수가 어떤 형식의 날짜 스트링을 유효하다고 판단하는지 알 수 있다.